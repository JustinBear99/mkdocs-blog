{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Hi, my name is Justin Hsiung, a software engineer located in Taiwan!</p> <p>That coffee link </p>"},{"location":"tags/","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"tags/#bitbake","title":"BitBake","text":"<ul> <li>Configure Case Sensitivity of File System</li> <li>Extend Nginx Service from OpenEmbedded Default Recipe</li> <li>Install Python Modules in Yocto</li> </ul>"},{"location":"tags/#bytebytego","title":"ByteByteGo","text":"<ul> <li>What are database isolation levels? What are they used for?</li> <li>What is ByteByteGo</li> </ul>"},{"location":"tags/#code-server","title":"Code Server","text":"<ul> <li>Self-hosted Cloud Development Environment</li> </ul>"},{"location":"tags/#community","title":"Community","text":"<ul> <li>Python\u5b98\u65b9\u6587\u4ef6\u7ffb\u8b6f \u7dda\u4e0bmeetup</li> </ul>"},{"location":"tags/#cool","title":"Cool","text":"<ul> <li>Self-hosted Cloud Development Environment</li> </ul>"},{"location":"tags/#embedded","title":"Embedded","text":"<ul> <li>Embedded</li> <li>Configure Case Sensitivity of File System</li> <li>Extend Nginx Service from OpenEmbedded Default Recipe</li> <li>Install Python Modules in Yocto</li> </ul>"},{"location":"tags/#google-cloud-study-jam","title":"Google Cloud Study Jam","text":"<ul> <li>Google Cloud Study Jam 2023</li> </ul>"},{"location":"tags/#leetcode","title":"LeetCode","text":"<ul> <li>1160. Find Words That Can Be Formed by Characters</li> <li>1662. Check If Two String Arrays are Equivalent</li> <li>1424. Diagonal Traverse II</li> <li>1441. Build an Array With Stack Operations</li> <li>1503. Last Moment Before All Ants Fall Out of a Plank</li> <li>1535. Find the Winner of an Array Game</li> <li>1561. Maximum Number of Coins You Can Get</li> <li>1611. Minimum One Bit Operations to Make Integers Zero</li> <li>1630. Arithmetic Subarrays</li> <li>1685. Sum of Absolute Differences in a Sorted Array</li> <li>1727. Largest Submatrix With Rearrangements</li> <li>1743. Restore the Array From Adjacent Pairs</li> <li>1759. Count Number of Homogenous Substrings</li> <li>1814. Count Nice Pairs in an Array</li> <li>1838. Frequency of the Most Frequent Element</li> <li>1845. Seat Reservation Manager</li> <li>1846. Maximum Element After Decreasing and Rearranging</li> <li>1877. Minimize Maximum Pair Sum in Array</li> <li>1887. Reduction Operations to Make the Array Elements Equal</li> <li>191. Number of 1 Bits</li> <li>1921. Eliminate Maximum Number of Monsters</li> <li>1930. Unique Length-3 Palindromic Subsequences</li> <li>1980. Find Unique Binary String</li> <li>2147. Number of Ways to Divide a Long Corridor</li> <li>2265. Count Nodes Equal to Average of Subtree</li> <li>2391. Minimum Amount of Time to Collect Garbage</li> <li>2642. Design Graph With Shortest Path Calculator</li> <li>2785. Sort Vowels in a String</li> <li>501. Find Mode in Binary Search Tree</li> <li>935. Knight Dialer</li> <li>1220. Count Vowels Permutation</li> <li>1356. Sort Integers by The Number of 1 Bits</li> <li>2433. Find The Original Array of Prefix Xor</li> <li>458. Poor Pigs</li> <li>5. Longest Palindromic Substring</li> <li>823. Binary Trees with Factors</li> </ul>"},{"location":"tags/#nginx","title":"Nginx","text":"<ul> <li>Extend Nginx Service from OpenEmbedded Default Recipe</li> </ul>"},{"location":"tags/#ngrok","title":"Ngrok","text":"<ul> <li>Self-hosted Cloud Development Environment</li> </ul>"},{"location":"tags/#oop","title":"OOP","text":"<ul> <li>Object-Oriented Programming Introduction</li> </ul>"},{"location":"tags/#python","title":"Python","text":"<ul> <li>Install Python Modules in Yocto</li> <li>Python\u5b98\u65b9\u6587\u4ef6\u7ffb\u8b6f \u7dda\u4e0bmeetup</li> </ul>"},{"location":"tags/#system-design","title":"System Design","text":"<ul> <li>What are database isolation levels? What are they used for?</li> <li>What is ByteByteGo</li> </ul>"},{"location":"tags/#yocto","title":"Yocto","text":"<ul> <li>Configure Case Sensitivity of File System</li> <li>Extend Nginx Service from OpenEmbedded Default Recipe</li> <li>Install Python Modules in Yocto</li> </ul>"},{"location":"career/","title":"Career","text":"<p>My ideas about software development</p> <ul> <li>Leetcode: problem solving notes</li> <li>System design: my perspective about designing system</li> <li>Embedded: experience about embedded software developing </li> <li>General: like others, knowledge that a software engineer should know</li> </ul>"},{"location":"career/embedded/","title":"Embedded","text":"<p>Share experience and things I've learned from embedded software development.</p> <ul> <li>Yocto: An open source project for building customized Linux distro. Widely used in embedded and IoT world.</li> </ul>","tags":["Embedded"]},{"location":"career/embedded/yocto/configure-case-sensitivity-of-file-system/","title":"Configure Case Sensitivity of File System","text":"","tags":["Embedded","Yocto","BitBake"]},{"location":"career/embedded/yocto/configure-case-sensitivity-of-file-system/#while-building-an-image-of-yocto-project","title":"While building an image of yocto project","text":"<p>My build environment is created from Docker Ubuntu 22.04 on Win11 laptop. While setting up for building yocto project, I've encountered some dependency issues but those can be fixed with <code>apt install xxx</code> from the message feedback by <code>bitbake</code>. However, since the file system is provided by WSL2, aka windows OS, I still have to adjust the case sensitivity setting from the host.</p> <pre><code>build@e57acb0162c2:~/yocto/build$ bitbake imx-image-multimedia\nNOTE: Bitbake server didn't start within 5 seconds, waiting for 90\nWARNING: You are running bitbake under WSLv2, this works properly but you should optimize your VHDX file eventually to avoid running out of storage space\nERROR:  OE-core's config sanity checker detected a potential misconfiguration.\n    Either fix the cause of this error or at your own risk disable the checker (see sanity.conf).\n    Following is the list of potential problems / advisories:\n\n    The TMPDIR (/home/build/yocto/build/tmp) can't be on a case-insensitive file system.\n\n\nSummary: There was 1 WARNING message.\nSummary: There was 1 ERROR message, returning a non-zero exit code.\n</code></pre>","tags":["Embedded","Yocto","BitBake"]},{"location":"career/embedded/yocto/configure-case-sensitivity-of-file-system/#solution","title":"Solution","text":"<p>Follow the guideline from Microsoft. We can use <code>PowerShell</code> <code>cd</code> to the build folder and command <code>fsutil.exe file setCaseSensitiveInfo tmp enable</code> to the the directory <code>tmp</code>.</p> <p>Notice that the command only works for empty directory and the child dirs inherited the case sensitivity. So next time, we should change the sensitivity before setting up the build environment. \ud83d\ude02</p>","tags":["Embedded","Yocto","BitBake"]},{"location":"career/embedded/yocto/extend-nginx-conf-from-oe/","title":"Extend Nginx Service from OpenEmbedded Default Recipe","text":"","tags":["Embedded","Yocto","BitBake","Nginx"]},{"location":"career/embedded/yocto/extend-nginx-conf-from-oe/#add-nginx-in-layer-config","title":"Add Nginx in Layer Config","text":"<p>Nginx has default recipe (<code>.bb</code> file) and <code>files</code> defined by <code>openembedded</code>, so first you have to make sure that you have those files included. They should locate at <code>/meta-openembedded/meta-webserver/recipes-httpd/nginx</code> including <code>files</code> folder and several versions of <code>.bb</code> files.</p> <p>If that's the case, you can simply add it in your <code>bblayers.conf</code>, like</p> <pre><code>BBLAYERS += \"${BSPDIR}/sources/meta-openembedded/meta-webserver\"\n</code></pre>","tags":["Embedded","Yocto","BitBake","Nginx"]},{"location":"career/embedded/yocto/extend-nginx-conf-from-oe/#extend-nginx-default-settings","title":"Extend Nginx Default Settings","text":"<p>Since Nginx provides a convenient way to maintain and extend configuration by simply placing your custom setting inside specific folder (<code>/sites-enabled</code>, <code>/sites-available</code>), we can just adding some files without touching original recipe. (If you are unaware about what I just mentioned, I suggest to read the official doc or google nginx sites-enabled. There have been plenty of tutorials out there.)</p> <p>To define out custom Nginx recipe, you should put the files under your meta layer like: <pre><code>meta-mylayer/recipes-httpd/\n\u2514\u2500\u2500 nginx\n    \u251c\u2500\u2500 files\n    \u2502   \u251c\u2500\u2500 custom-nginx.conf\n    \u2502   \u251c\u2500\u2500 nginx.service\n    \u2502   \u2514\u2500\u2500 ssl\n    \u2502       \u251c\u2500\u2500 nginx.crt\n    \u2502       \u2514\u2500\u2500 nginx.key\n    \u2514\u2500\u2500 nginx_1.20.1.bbappend\n</code></pre></p> <p>Here, I extend Nginx of version 1.20.1 with my server definition in <code>custom-nginx.conf</code> and a systemd service <code>nginx.service</code>.</p> <p>Here is the example of <code>nginx_1.20.1.bbappend</code>:</p> <pre><code>FILESEXTRAPATHS:prepend := \"${THISDIR}/files:\"\n\nSRC_URI += \"file://custom-nginx.conf \\\n            file://ssl/ \\\n            file://nginx.service\"\n\ndo_install:append() {\n    # remove the example under /sites-enabled\n    rm ${D}${sysconfdir}/nginx/sites-enabled/*\n    install -m 0644 ${WORKDIR}/custom-nginx.conf ${D}${sysconfdir}/nginx/sites-enabled/custom-nginx.conf\n\n    mkdir -p ${D}${sysconfdir}/nginx/ssl\n    install -m 0644 ${WORKDIR}/ssl/nginx.crt ${D}${sysconfdir}/nginx/ssl/nginx.crt\n    install -m 0600 ${WORKDIR}/ssl/nginx.key ${D}${sysconfdir}/nginx/ssl/nginx.key\n    install -m 0644 ${WORKDIR}/nginx.service ${D}${systemd_system_unitdir}/nginx.service\n}\n\n# Add your custom configuration to nginx.conf\nFILES:${PN} += \"${sysconfdir}/nginx/sites-enabled/custom-nginx.conf\"\n\n# Define additional directories where SSL certificates may be stored\nFILES:${PN} += \"${sysconfdir}/nginx/ssl\"\n\n# Add SSL certificate and key files (modify the paths as needed)\nFILES:${PN} += \"${sysconfdir}/nginx/ssl/nginx.crt\"\nFILES:${PN} += \"${sysconfdir}/nginx/ssl/nginx.key\"\n\nFILES:${PN} += \"${systemd_system_unitdir}\"\n</code></pre> <p>Note that the example is based on Yocto 4.0.x. The syntax may differ for different version.</p> <p>Don't forget to include these in the <code>layer.conf</code></p>","tags":["Embedded","Yocto","BitBake","Nginx"]},{"location":"career/embedded/yocto/install-python-module/","title":"Install Python Modules in Yocto","text":"","tags":["Embedded","Yocto","BitBake","Python"]},{"location":"career/embedded/yocto/install-python-module/#pipoe-a-handy-tool-for-embedded-world","title":"pipoe: A Handy Tool for Embedded World","text":"<p>When developing Python apps in a Yocto project, we may have chances to use some modules that don't come within the default <code>/meta-openembedded/meta-python</code> or the version doesn't match our need. Therefore, we have to manually define the <code>.bb</code> files for those dependencies and that is a pain in the ass...</p> <p>Thankfully, there is a tool named <code>pipoe</code> working like <code>pip</code> but for <code>oe</code> (openembedded) that can generate <code>.bb</code> files for us (\ud83d\ude0d).</p> <pre><code>pip install pipoe\npipoe --package &lt;target_module&gt; --python &lt;python_version&gt;\n</code></pre> <p>The generated <code>.bb</code> files should be ready to go!</p>","tags":["Embedded","Yocto","BitBake","Python"]},{"location":"career/embedded/yocto/install-python-module/#build-by-setuppy-or-pypi","title":"Build by setup.py or Pypi","text":"<p>I believe that most Python developers know that there are many ways of install a module, <code>pip</code> with internet, <code>pip</code> with <code>wheel</code>, source with <code>setup.py</code>, yada yada. Although the community now is promoting <code>pyproject.toml</code> and <code>pypi</code> to build, there are still many projects using <code>setup.py</code> and <code>setuptools</code>. (Please correct me if wrong. I'm not a professional Python developer though.)</p> <p>Get back to the business. The generated <code>.bb</code> files all use <code>setuptools</code> to build and I've encountered several build errors. To fix these, you can manually change the build method to use <code>pypi</code> like me and here's the example.</p> <pre><code># python3-blinker_1.7.0.bb\nSUMMARY = \"Fast, simple object-to-object and broadcast signaling\"\nHOMEPAGE = \"\"\nAUTHOR = \" &lt;Jason Kirtland &lt;jek@discorporate.us&gt;&gt;\"\nLICENSE = \"MIT\"\nLIC_FILES_CHKSUM = \"file://LICENSE.rst;md5=42cd19c88fc13d1307a4efd64ee90e4e\"\n\nSRC_URI = \"https://files.pythonhosted.org/packages/a1/13/6df5fc090ff4e5d246baf1f45fe9e5623aa8565757dfa5bd243f6a545f9e/blinker-1.7.0.tar.gz\"\nSRC_URI[md5sum] = \"0306b831281e9918ffb0ac6e3e18b47f\"\nSRC_URI[sha256sum] = \"e6820ff6fa4e4d1d8e2747c2283749c3f547e4fee112b98555cdcdae32996182\"\n\nS = \"${WORKDIR}/blinker-1.7.0\"\n\nRDEPENDS:${PN} = \"\"\n\nFILES:${PN} += \"${libdir}/python3.10/site-packages/blinker\"\n\n# change to use pypi\ninherit pypi\n\n# manually install to site-packages and copy source there\ndo_install() {\n    install -m 777 -d ${D}${libdir}/python3.10/site-packages/\n    cp -r ${S}/src/blinker ${D}${libdir}/python3.10/site-packages/blinker\n}\n</code></pre>","tags":["Embedded","Yocto","BitBake","Python"]},{"location":"career/embedded/yocto/install-python-module/#other-issues","title":"Other Issues","text":"<p>From the above example, you can notice that the source was downloaded from some remote mirror website. Unfortunately, when I tried to install <code>MarkupSafe</code>, it seemed to be missing at the remote storage and having some capitailizing problem (MarkupSafe and markupsafe). So I have to manually download the <code>.tar.gz</code> file and install manually.</p> <p>Here is the exmaple for <code>MarkupSafe</code> 2.1.3</p> <pre><code>SUMMARY = \"Safely add untrusted strings to HTML/XML markup.\"\nHOMEPAGE = \"https://palletsprojects.com/p/markupsafe/\"\nAUTHOR = \" &lt;&gt;\"\nLICENSE = \"BSD-3-Clause\"\nLIC_FILES_CHKSUM = \"file://LICENSE.rst;md5=ffeffa59c90c9c4a033c7574f8f3fb75\"\n\n# manually download the source and put in `files`\nSRC_URI = \"file://MarkupSafe-2.1.3.tar.gz\"\nSRC_URI[md5sum] = \"ca33f119bd0551ce15837f58bb180214\"\nSRC_URI[sha256sum] = \"af598ed32d6ae86f1b747b82783958b1a4ab8f617b06fe68795c7f026abbdcad\"\n\n\nS = \"${WORKDIR}/MarkupSafe-2.1.3\"\n\nRDEPENDS:${PN} = \"\"\n\nFILES:${PN} += \"${libdir}/python3.10/site-packages/markupsafe\"\n\ninherit setuptools3\n\ndo_install() {\n    install -m 777 -d ${D}${libdir}/python3.10/site-packages/\n    cp -r ${WORKDIR}/MarkupSafe-2.1.3/src/markupsafe ${D}${libdir}/python3.10/site-packages/markupsafe\n}\n</code></pre>","tags":["Embedded","Yocto","BitBake","Python"]},{"location":"career/general/oop-basics/","title":"Object-Oriented Programming Introduction","text":"","tags":["OOP"]},{"location":"career/general/oop-basics/#what-is-oop","title":"What is OOP?","text":"<p>Object-oriented concept basically wants to make the programming easier by abstracting the code to material-world like. Therefore, the developer can easily build large functioning software with strong reference.</p>","tags":["OOP"]},{"location":"career/general/oop-basics/#class-and-object","title":"Class and Object","text":"<p>Class is the fundation in OOP. It defines the boundaries for data and operations of an abstract concept. For example, a class named <code>Cat</code> should contain data of <code>color</code>, <code>genre</code>, <code>weight</code>, <code>age</code> and operations of <code>eat()</code>, <code>drink()</code>, <code>play()</code> and <code>poop()</code>.</p> <p>Object is the instance of Class. One may create many objects of the same class. Just like you feed multiple cats in your home and those cats can live with different <code>color</code> and <code>age</code>. Those data and operations can be stored and opeared independently.</p>","tags":["OOP"]},{"location":"career/general/oop-basics/#main-concepts","title":"Main Concepts","text":"","tags":["OOP"]},{"location":"career/general/oop-basics/#encapsulation","title":"Encapsulation","text":"<p>Encapsulation means the objects can hide its data and the detail of its opeartion implementation and only provide interface for others to access. This feature ensures the safety that no others can change the behavior of some object. Also, in my opinion, it makes the developer easier to use because you don't bother to understand how it works but only what it can do.</p>","tags":["OOP"]},{"location":"career/general/oop-basics/#inheritance","title":"Inheritance","text":"<p>Inheritance is to extends the original class to add or to adjust more features that previously defined. For example, <code>Cat</code> can be inherited from class <code>Animal</code> which has <code>numberOfLegs()</code> opeation. Also, <code>Cat</code> may add new <code>play()</code> for not every animals would play with humane. Overall, inheritance makes the relationship of classes clearer and let developer to mapping more complicated classes without duplicated code.</p>","tags":["OOP"]},{"location":"career/general/oop-basics/#polymorphism","title":"Polymorphism","text":"<p>Polymorphism basically implies that the methods of same name provide by some class can have different behaviors. Polymorphism can be furthur divided into Overloading and Overriding.</p> <p>Overloading means that the methods of same name can accepted different inputs whatever the number of the types. For example, you can let <code>Cat</code> <code>eat(DryFood)</code> or <code>eat(Can)</code> and the result might be sad and happy. </p> <p>Overriding means that the method inherited from its parent class can be changed. For example, <code>Animal</code> have <code>numberOfLegs()</code> return 2 by default, but <code>Cat</code> can redefined this method to return 4.</p>","tags":["OOP"]},{"location":"career/general/oop-basics/#conclusion","title":"Conclusion","text":"<p>OOP is an idea that every developer faces everyday, but few can explain to others intuitively. After writing this article, I feel like knowing this basic concept more. Hope this is also helpful for you. :)</p>","tags":["OOP"]},{"location":"career/general/remote-dev-env/","title":"Self-hosted Cloud Development Environment","text":"","tags":["Cool","Code Server","Ngrok"]},{"location":"career/general/remote-dev-env/#what-is-it","title":"What is it?","text":"<p>As more and more work flows such as building and deployment have been moved onto the cloud, further moving coding to the remote is not a strange idea. This movement ensures that developer can have consistent working experience through different devices. Many cloud development environment (CDE) like Github Codespaces and Gitpod have been released for a while. However, the free tier membership has very limited use time, so I start to research on how to achieve it on my own device.</p>","tags":["Cool","Code Server","Ngrok"]},{"location":"career/general/remote-dev-env/#all-you-need-is-a-pc","title":"All You Need is a PC","text":"<p>Disclaimer: my approach includes only the coding part. Following steps like building and deployment still require to DIY or other existing tools. :)</p> <p>Basically we need an multifunctional IDE accessible from browser and have to expose it onto public network (ingress), so here comes code server and Ngrok. BTW, both are free FOREver (?).</p> <p>Code server runs VSCode on your machine and can be accessed through browser which means that you can benifit from VSCode's powerful extensions. I think almost any kinds of development requirements can be fulfilled, from linter, git to container (at least terminal). Ngrok then provide secure ingress to safely connects to your home machine from everywhere. Recently, they even provide free static domain name for everyone (it was randomly generated every time). Although you can't name it, it's still awesome!</p> <p>The overall setup is very easy and take my own as example. I use a M1 mac mini (8/128GB) as my host server which also cover my use at home running a bunch of APPs in background. 1. Run <code>curl -fsSL https://code-server.dev/install.sh | sh</code> to install latest code-server. 2. Open a terminal and run <code>code-server</code> and everything is ready-to-go. You can login with password or from other options. 3. Create account for Ngrok 4. Download and configure it. 5. Start coding!</p> <p>Have been using these for a couple of months and they works perfect and steady. \ud83d\ude0a</p>","tags":["Cool","Code Server","Ngrok"]},{"location":"career/general/remote-dev-env/#next-step","title":"Next Step","text":"<p>Both code-server and Ngrok are running in Mac OS rn in my setup. Maybe one day I'll move them to a dedicated container based on Linux and add some useful CI/CD tools. But that should happend when I'm working on larger side project. XD</p>","tags":["Cool","Code Server","Ngrok"]},{"location":"career/leetcode/","title":"LeetCode","text":"<p>Every software developer's mightmare.</p> <p>I'll share some of my solution here.</p>"},{"location":"career/leetcode/daily/dec2023/1160-find-words-that-can-be-formed-by-characters/","title":"1160. Find Words That Can Be Formed by Characters","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/dec2023/1160-find-words-that-can-be-formed-by-characters/#description","title":"Description","text":"<p>Given a list of words and a string, <code>chars</code>. We are asked to find the total sum of words that can be formed by <code>chars</code></p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/dec2023/1160-find-words-that-can-be-formed-by-characters/#code","title":"Code","text":"<p>Just do it intuitively.</p> <pre><code>class Solution:\n    def countCharacters(self, words: List[str], chars: str) -&gt; int:\n        ans = 0\n        s = {}\n        for char in chars:\n            if char not in s:\n                s[char] = 0\n            s[char] += 1\n        for word in words:\n            if self.formable(word, s.copy()):\n                ans += len(word)\n        return ans\n\n    def formable(self, word, s):\n        for char in word:\n            if char not in s or s[char] &lt; 1:\n                return False\n            s[char] -= 1\n        return True\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/dec2023/1662-check-if-two-string-arrays-are-equivalent/","title":"1662. Check If Two String Arrays are Equivalent","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/dec2023/1662-check-if-two-string-arrays-are-equivalent/#description","title":"Description","text":"<p>Determine if two list of strings are the same after concatenated.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/dec2023/1662-check-if-two-string-arrays-are-equivalent/#code","title":"Code","text":"<p>Since it's an easy problem, do it easily.</p> <pre><code>class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -&gt; bool:\n        return \"\".join(word1) == \"\".join(word2)\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1424-diagonal-traverse-2/","title":"1424. Diagonal Traverse II","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1424-diagonal-traverse-2/#description","title":"Description","text":"<p>Sort 2-d matrix with given order.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1424-diagonal-traverse-2/#intuition","title":"Intuition","text":"<p>The attribute of this diagonal order is that the position (i, j) of the same diagonal has same <code>i + j</code> value. Hence, we can sort the matrix by <code>i + j</code>, <code>j</code> and then <code>i</code>. However, the built-in sorting function has time complexity of O(nlogn) which is pretty slow.</p> <p>To manually sort the matrix, we can still use that attribute and create a bucket for holding those value with order. Thus, the time complexity will drop to O(n)</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1424-diagonal-traverse-2/#code","title":"Code","text":"<pre><code>class Solution:\n    def findDiagonalOrder(self, nums: List[List[int]]) -&gt; List[int]:\n        ## 1. O(nlogn)\n        # s = set()\n        # for i in range(len(nums)):\n        #     for j in range(len(nums[i])):\n        #         s.add((i + j, j, i, nums[i][j]))\n        # return [n[3] for n in sorted(s)]\n\n        ## 2. O(n)\n        s = []\n        for i in range(len(nums)):\n            for j in range(len(nums[i])):\n                # add a container for holding diagonal sum equals to (i+j)\n                if i + j &gt;= len(s):\n                    s.append([])\n                s[i + j].append(nums[i][j])\n        return [ n for r in s for n in r[::-1]] # remember to reverse r(row) since we put values reversely\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1441-build-an-array-with-stack-operations/","title":"1441. Build an Array With Stack Operations","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1441-build-an-array-with-stack-operations/#description","title":"Description","text":"<p>Given a array with numbers range from 1 to n, return the operation list to form the array.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1441-build-an-array-with-stack-operations/#intuition","title":"Intuition","text":"<p>There are only two situation we faced with the <code>target</code> while growing the number stream n</p> <ol> <li>n == target entry: Push into the operation list.</li> <li>n != target entry: Push and then Pop since we don't need it. (could only be less than, so I use <code>while</code> loop)</li> </ol>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1441-build-an-array-with-stack-operations/#code","title":"Code","text":"<pre><code>class Solution:\n    def buildArray(self, target: List[int], n: int) -&gt; List[str]:\n        ans = []\n        s = 1\n        for t in target:\n             # s always &lt; n, don't bother to check\n            while s &lt; t:\n                s += 1\n                ans.append(\"Push\")\n                ans.append(\"Pop\")\n            s += 1\n            ans.append(\"Push\")\n        return ans\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1441-build-an-array-with-stack-operations/#complexity","title":"Complexity","text":"<p>The time complexity is O(m) where m is the last entry of <code>target</code>.</p> <p>The space complexity is O(m+n) where m is the last entry of <code>target</code> and n is m minus the length of <code>target</code>.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1503-last-moment-before-all-ants-fall-out-of-a-plank/","title":"1503. Last Moment Before All Ants Fall Out of a Plank","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1503-last-moment-before-all-ants-fall-out-of-a-plank/#description","title":"Description","text":"<p>There are two lines of ants moving on the same line. As they met each other, they switch the direction and keep moving avoiding each other.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1503-last-moment-before-all-ants-fall-out-of-a-plank/#intuition","title":"Intuition","text":"<p>The movement of ants is actually very simple. It doesn't matter when they meet since the result is the same as they avoid each other. So, we can treat them like the right-goers are on the one line and the left-goers are on the another.</p> <ol> <li>The time for <code>left</code> to finish is <code>max(left)</code></li> <li>And the time for <code>right</code> to finish is <code>n - min(right)</code></li> <li>Since we can treat them on two independent lines, the answer is the <code>max()</code> of the above.</li> </ol>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1503-last-moment-before-all-ants-fall-out-of-a-plank/#code","title":"Code","text":"<pre><code>class Solution:\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -&gt; int:\n        # add default value for empty list\n        return max(max(left, default=0), (n - min(right, default=n)))\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1535-find-the-winner-of-an-array-game/","title":"1535. Find the Winner of an Array Game","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1535-find-the-winner-of-an-array-game/#description","title":"Description","text":"<p>We wan to find the first one that meet a win streak of <code>k</code> from the given <code>arr</code> with the losed one added back to <code>arr</code>. Therefore, <code>k</code> can be larger than the length of <code>arr</code></p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1535-find-the-winner-of-an-array-game/#intuition","title":"Intuition","text":"<p>Follow the rules from the problem to use queue and while loop for comparision since the problem promise that the answer exist.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1535-find-the-winner-of-an-array-game/#code","title":"Code","text":"<pre><code>class Solution:\n    def getWinner(self, arr: List[int], k: int) -&gt; int:\n        # Only the largest one can have win streak more or equal to the number of whole group.\n        if k &gt;= len(arr):\n            return max(arr)\n\n        streak = 0\n        q = collections.deque(arr)\n        defender = q.popleft()\n\n        while streak &lt; k:\n            challenger = q.popleft()\n            if defender &gt; challenger:\n                q.append(challenger)\n                streak += 1\n            else:\n                q.append(defender)\n                defender = challenger\n                streak = 1\n        return defender\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1561-maximum-number-of-coins-you-can-get/","title":"1561. Maximum Number of Coins You Can Get","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1561-maximum-number-of-coins-you-can-get/#description","title":"Description","text":"<p>We are given array <code>piles</code> of length 3n and asked to find the maximum sum from selecting piles followed by the rules.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1561-maximum-number-of-coins-you-can-get/#intuition","title":"Intuition","text":"<p>Simply a sorting question. After sorted reversely (from large to small), the array looks like</p> <pre><code> L M L M L M L M S S S S \n|------2/3------|--1/3--|\n</code></pre> <p>Now, we just need to sum up all <code>M</code> values</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1561-maximum-number-of-coins-you-can-get/#code","title":"Code","text":"<pre><code>class Solution:\n    def maxCoins(self, piles: List[int]) -&gt; int:\n        piles.sort(reverse=True)\n        return sum([ piles[i] for i in range(1, int(len(piles) * 2 / 3), 2)])\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1611-minimum-one-bit-operations-to-make-integers-zero/","title":"1611. Minimum One Bit Operations to Make Integers Zero","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1611-minimum-one-bit-operations-to-make-integers-zero/#description","title":"Description","text":"<p>Given two operations:</p> <ol> <li>Change rightmost bit from <code>0</code> to <code>1</code> or from <code>1</code> to <code>0</code></li> <li>Change <code>i</code>th bit as the above as long as <code>i-1</code> bit is <code>1</code> and rest of <code>i-2</code> bits are <code>0</code> (indexing from right to left)</li> </ol> <p>Find the minimum operations to make integer <code>n</code> to zero.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1611-minimum-one-bit-operations-to-make-integers-zero/#intuition","title":"Intuition","text":"<p>At first, I thought that the question can be solved by DP like <code>f(make n bits zero) = f(let nth bit zero) + f(make n-1 bits zero)</code> and can solve it bit by bit. But turns out that this approach would require a lot more analysis in detail.</p> <p>Thanks to lee's and delphih's solutions, this problem actually requires more analysis on the recursive behaviour.</p> <ol> <li>Symmetric: operations required to change <code>m</code> to <code>n</code> is the same as changing from <code>n</code> to <code>m</code>. i.e. <code>f(m-&gt;n) = f(n-&gt;m)</code></li> <li>2^k: The operations required from <code>2^k</code> (<code>100..00</code> in binary) to <code>0</code> is calculable and is <code>2^(k + 1) - 1</code>. i.e. <code>f(n if n == 2^k where k is int) = 2^(k + 1) - 1</code></li> </ol> <p>Therefore, to solve ant given number <code>n</code> equals to sovle <code>1XXXXX</code> (in binary)</p> <p>So  <pre><code>f(100000 -&gt; 0) = f(100000 -&gt; 1XXXXX) + f(1XXXXX -&gt; 0)\n               = f(1XXXXX -&gt; 100000) + f(1XXXXX -&gt; 0)\n               = f(0XXXXX -&gt; 000000) + f(1XXXXX -&gt; 0)\n-&gt;\nf(1XXXXX -&gt; 0) = f(100000 -&gt; 0) - f(XXXXX -&gt; 0) \n</code></pre></p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1611-minimum-one-bit-operations-to-make-integers-zero/#code","title":"Code","text":"<pre><code>class Solution:\n    def minimumOneBitOperations(self, n: int) -&gt; int:\n        if n == 0:\n            return 0\n        highest_bit = int(math.log2(n))\n        return self.makeIthBitZero(highest_bit) - self.minimumOneBitOperations(n - (1 &lt;&lt; highest_bit))\n\n    @lru_cache\n    def makeIthBitZero(self, i):\n        return (1 &lt;&lt; (i + 1)) - 1 # equals to 2 ** (i + 1) - 1\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1611-minimum-one-bit-operations-to-make-integers-zero/#gray-code","title":"Gray Code","text":"<p>This problem actually comes from gray code, a special order of binary code used in some digital procressing.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1630-arithmetic-subarrays/","title":"1630. Arithmetic Subarrays","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1630-arithmetic-subarrays/#description","title":"Description","text":"<p>Given integer list <code>nums</code>, we are asked to find if the subarray from index <code>i</code> to <code>j</code> is arithmetic or not. See the definition in the problem.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1630-arithmetic-subarrays/#intuition","title":"Intuition","text":"<p>After seeing the problem, my first idea is to use dynamic programming or sliding window stuff to iterate combination. However, soon I realized that the result of subarray <code>(i, j)</code> is either independent to subarray <code>(i, j + 1)</code> or <code>(i, j - 1)</code>, etc. We actually can't reuse the result for optimizing our alogorithm.</p> <p>The brute force way is to determine <code>m</code> subarray independenty with sorting. The time complexity is expected to be <code>O(m * nlog(n))</code> where <code>n</code> is the average length of subarray.</p> <p>To decrease the time consumed (use methods of time complexity less than <code>O(nlogn)</code> only), we should rethink about the criteria about arithmaic subarray. If an array is arithmatic, we can confirm that the difference of adjacent elements are the same and equals to <code>(max - min) / (size - 1)</code>. For example, if there is an array <code>[40, 20, 60, 30, 50, 10]</code>. After looping and finding that the min=<code>10</code> and max=<code>60</code>, it is expected that elements <code>20</code>, <code>30</code>, <code>40</code> and <code>50</code> should be at index <code>1</code>, <code>2</code>, <code>3</code>and <code>4</code>. If we can't find the index exists or the indexes not filled, then the array is not arithmatic. The overall time complexity will be <code>O(m*n)</code>.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1630-arithmetic-subarrays/#code","title":"Code","text":"<pre><code># First intuition, easy and takes time (not bad actually).\nclass Solution:\n    def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r: List[int]) -&gt; List[bool]:\n        def isArithmetic(nums):\n            nums.sort()\n            for i in range(2, len(nums)):\n                if nums[i] - nums[i - 1] != nums[i - 1] - nums[i - 2]:\n                    return False\n            return True\n\n        ans = []\n        for i in range(len(l)):\n            sub = nums[l[i]: r[i] + 1]\n            ans.append(isArithmetic(sub))\n        return ans\n\n# Second intuition but fail at edge cases. Don't want to fix this, just a reference. lol\nclass Solution:\n    def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r: List[int]) -&gt; List[bool]:\n        def isArithmetic(nums):\n            n = len(nums)\n            ret = [None] * n\n            mini, maxi = float(\"inf\"), float(\"-inf\")\n            for num in nums:\n                if num &lt; mini:\n                    mini = num\n                elif num &gt; maxi:\n                    maxi = num\n            diff = (maxi - mini) / (n - 1)\n            if not diff.is_integer():\n                return False\n            diff = int(diff)\n            if diff == 0:\n                for num in nums:\n                    if num != mini:\n                        return False\n            else:\n                for num in nums:\n                    index = (num - mini) / diff\n                    if not index.is_integer():\n                        return False\n                    index = int(index)\n                    if index &lt; n:\n                        ret[index] = True\n            return not (None in ret)\n\n        ans = []\n        for i in range(len(l)):\n            sub = nums[l[i]: r[i] + 1]\n            ans.append(isArithmetic(sub))\n        return ans\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1685-sum-of-absolute-differences-in-a-sorted-array/","title":"1685. Sum of Absolute Differences in a Sorted Array","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1685-sum-of-absolute-differences-in-a-sorted-array/#description","title":"Description","text":"<p>We are asked to find the sum of absolute difference for every element with respect to other elements in a sorted array. </p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1685-sum-of-absolute-differences-in-a-sorted-array/#intuition","title":"Intuition","text":"<p>As the array, <code>nums</code>, is sorted, we can get rid of <code>abs()</code> operation to calculate difference sum. In other words, difference sum of index <code>i</code> equals to <code>nums[i] * (i + 1) - sum(nums[:i])</code> plus <code>sum(nums[i:]) - nums[i] * (n - i - 1)</code>. Also, we can use prefix sum to prevent repetitive sum operation.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1685-sum-of-absolute-differences-in-a-sorted-array/#code","title":"Code","text":"<pre><code>class Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -&gt; List[int]:\n        n = len(nums)\n        p_sum = [0] * n\n        for i in range(n):\n            p_sum[i] = p_sum[i - 1] + nums[i]\n\n        ans = []\n        for i in range(n):\n            pre = p_sum[i] # includes nums[i]\n            post = p_sum[-1] - p_sum[i]\n            s_pre = nums[i] * (i + 1) - pre \n            s_post = post - nums[i] * (n - i - 1)\n            ans.append(s_pre + s_post)\n        return ans\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1727-largest-submatrix-with-rearrangements/","title":"1727. Largest Submatrix With Rearrangements","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1727-largest-submatrix-with-rearrangements/#description","title":"Description","text":"<p>We are asked to find the largest matrix such that the values of this matrix are all <code>1</code>. We can switch the column of the given matrix but not for the row.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1727-largest-submatrix-with-rearrangements/#intuition","title":"Intuition","text":"<p>Actually, I follow the idea from jailwalankit (please upvote his solution) since I'm not good at this kind of spatial question and didn't figure out in 5 mins.</p> <p>Anyway, the idea is to find the number of consecutive <code>1</code>s looking up from a cell so we don't bother to look at a segment to matrix to know the maximum possible submatrix height. The second step is to sort the row to find the width.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1727-largest-submatrix-with-rearrangements/#code","title":"Code","text":"<pre><code>class Solution:\n    def largestSubmatrix(self, matrix: List[List[int]]) -&gt; int:\n        m, n = len(matrix), len(matrix[0])\n\n        for i in range(1, m):\n            for j in range(n):\n                if matrix[i][j] == 1:\n                    matrix[i][j] += matrix[i - 1][j]\n        ans = 0\n        for i in range(m):\n            matrix[i].sort(reverse=True)\n            for j in range(n):\n                ans = max(ans, matrix[i][j] * (j + 1))\n        return ans\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1743-restore-the-array-from-adjacent-pairs/","title":"1743. Restore the Array From Adjacent Pairs","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1743-restore-the-array-from-adjacent-pairs/#description","title":"Description","text":"<p>The original array was separated into the adjacent pairs. Since it's a 1-d array, except for the start and the end, every elemnt has two adjacent neighbors. To keep track of the relations, the common approach is to use hash map. </p> <p>We can expect that the start and the end can only map to 1 element and all the other elements can map to 2 elements.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1743-restore-the-array-from-adjacent-pairs/#intuition","title":"Intuition","text":"<ol> <li>Build hash map for every pair. For example, pair = [a, b], then link a to b and b to a.</li> <li>Find an end for the original array.</li> <li>Rebuild the array recursively by the hash map</li> </ol>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1743-restore-the-array-from-adjacent-pairs/#code","title":"Code","text":"<pre><code>class Solution:\n    def restoreArray(self, adjacentPairs: List[List[int]]) -&gt; List[int]:\n        # build hash map\n        table = {}\n        for i, j in adjacentPairs:\n            if i not in table:\n                table[i] = []\n            if j not in table:\n                table[j] = []\n            table[i].append(j)\n            table[j].append(i)\n        # find an end\n        ans = []\n        for k, v in table.items():\n            if len(v) == 1:\n                ans.append(k)\n                ans.append(table[k][0])\n                break\n        # reconstruct the array\n        while True:\n            last = ans[-1]\n            vals = table[last]\n            if len(vals) == 1:\n                # the other end found\n                break\n            # find the other adjacent\n            elif vals[0] != ans[-2]:\n                ans.append(vals[0])\n            else:\n                ans.append(vals[1])\n        return ans\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1759-count-number-of-homogenous-substrings/","title":"1759. Count Number of Homogenous Substrings","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1759-count-number-of-homogenous-substrings/#description","title":"Description","text":"<p>Count the number of substrings that have the same character (homogeneous), including duplicates and the substrings must be contiguous.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1759-count-number-of-homogenous-substrings/#intuition","title":"Intuition","text":"<p>The number of homogenous substring of <code>n</code> characters is 1+2+...+n. So we can calculate how many of substrings that have length of <code>n</code> and sum them up with the equation.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1759-count-number-of-homogenous-substrings/#code","title":"Code","text":"<pre><code>class Solution:\n    def countHomogenous(self, s: str) -&gt; int:\n        # the equation for 1+2+...+n\n        def countByLength(l):\n            return sum(range(1, l + 1, 1))\n\n        i, j = 0, 0\n        d = {}\n        # loop over the given string and use a map to store how many substrings that have length = 1 or 2 or ...\n        while j &lt; len(s):\n            if s[j] == s[i]:\n                j += 1\n            else:\n                d[j - i] = d.get(j - i, 0) + 1\n                i = j\n        d[j - i] = d.get(j - i, 0) + 1\n        ans = 0\n        for k, v in d.items():\n            ans += v * countByLength(k)\n        return ans % (10 ** 9 + 7)\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1814-count-nice-pairs-in-an-array/","title":"1814. Count Nice Pairs in an Array","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1814-count-nice-pairs-in-an-array/#description","title":"Description","text":"<p>We are asked to find the number of pairs <code>(a, b)</code> such that <code>a + reverse(b) = reverse(a) + b</code> where <code>reverse()</code> reverses the integer by its string representation.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1814-count-nice-pairs-in-an-array/#intuition","title":"Intuition","text":"<p>Slightly change the equation <code>a + reverse(b) == reverse(a) + b</code> to <code>a - reverse(a) = b - reverse(b)</code> so then we can simply make a hash table to store the count by the difference (n - reverse(n)).</p> <p>Be aware of the edge cases for <code>reverse()</code> and remember to <code>/2</code> for duplicated pairs.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1814-count-nice-pairs-in-an-array/#code","title":"Code","text":"<pre><code>class Solution:\n    def countNicePairs(self, nums: List[int]) -&gt; int:\n        rev_nums = [ self.reverse(num) for num in nums]\n        table = {}\n        for i in range(len(nums)):\n            diff = nums[i] - rev_nums[i]\n            if diff not in table:\n                table[diff] = 0\n            table[diff] += 1\n        ans = 0\n        for val in table.values():\n            if val &gt; 1:\n                ans += int(val * (val - 1) / 2)\n        return ans % (10 ** 9 + 7)\n\n    def reverse(self, num):\n        s = []\n        while num &gt;= 10:\n            q = num % 10\n            num = num // 10\n            s.append(q)\n        if num &gt; 0:\n            s.append(num)\n\n        i = 0\n        rev = 0\n        while s:\n            rev += (10 ** i) * s.pop()\n            i += 1\n        return int(rev)\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1838-frequency-of-the-most-frequent-element/","title":"1838. Frequency of the Most Frequent Element","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1838-frequency-of-the-most-frequent-element/#description","title":"Description","text":"<p>We are given <code>k</code> quota to increase the elements in <code>nums</code> to maximize the number of any value.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1838-frequency-of-the-most-frequent-element/#intuition","title":"Intuition","text":"<ol> <li>Sort the array since we can only add value to the elements and only the smaller element should be considered added for larger element.</li> <li>Use two poninters (sliding window) to determine how many elements can be increased and be equal to the larger element.</li> <li>Also, use prefix sum to prevent repetitive summation.</li> </ol>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1838-frequency-of-the-most-frequent-element/#code","title":"Code","text":"<pre><code>class Solution:\n    def maxFrequency(self, nums: List[int], k: int) -&gt; int:\n        nums.sort()\n        n = len(nums)\n        psum = [0] * (n + 1)\n        i, j = 0, 0\n        ans = 0\n        while j &lt; n:\n            psum[j] = psum[j - 1] + nums[j]\n            if (nums[j] * (j - i + 1)) - (psum[j] - psum[i - 1]) &lt;= k:\n                ans = max(ans, j - i + 1)\n                j += 1\n            else:\n                i += 1\n        return ans\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1845-seat-reservation-manager/","title":"1845. Seat Reservation Manager","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1845-seat-reservation-manager/#description","title":"Description","text":"<p>From the problem statement, the manager is apparently an application of priority queue. In Python, there is a common used priority queue implementation named <code>heapq</code> that uses heap (binary tree) to implement.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1845-seat-reservation-manager/#heap","title":"Heap","text":"<p>There have been a lot of tutorial on this data structure on the net, so I just leave some useful links here (maybe write an explanation of my own version in the future XD).</p> <p>wiki g4g</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1845-seat-reservation-manager/#code","title":"Code","text":"<pre><code>class SeatManager:\n\n    def __init__(self, n: int):\n        self.pq = [ i for i in range(1, n + 1)]\n\n    def reserve(self) -&gt; int:\n        return heapq.heappop(self.pq)\n\n    def unreserve(self, seatNumber: int) -&gt; None:\n        heapq.heappush(self.pq, seatNumber)\n\n\n# Your SeatManager object will be instantiated and called as such:\n# obj = SeatManager(n)\n# param_1 = obj.reserve()\n# obj.unreserve(seatNumber)\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1846-maximum-element-after-decreasing-and-rearranging/","title":"1846. Maximum Element After Decreasing and Rearranging","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1846-maximum-element-after-decreasing-and-rearranging/#description","title":"Description","text":"<p>We are asked to find the maximum value from a array which will change after satisfying the rules required. Basically, after sorting the array, since the increment between elements is atmost 1, we just update the element and return the last element.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1846-maximum-element-after-decreasing-and-rearranging/#code","title":"Code","text":"<pre><code>class Solution:\n    def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -&gt; int:\n        arr.sort()\n        # edge case\n        if arr[0] != 1:\n            return len(arr)\n        for i in range(1, len(arr)):\n            if arr[i] - arr[i - 1] &gt; 1:\n                arr[i] = arr[i - 1] + 1\n        return arr[-1]\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1877-minimize-maximum-pair-sum-in-array/","title":"1877. Minimize Maximum Pair Sum in Array","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1877-minimize-maximum-pair-sum-in-array/#description","title":"Description","text":"<p>Find the maximum sum of pair in <code>nums</code> from <code>len(nums) / 2</code> pairs formed by <code>nums</code> and no duplicates. And then, minimized the maximum value.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1877-minimize-maximum-pair-sum-in-array/#intuition","title":"Intuition","text":"<p>To make the pair sum minimized, we can greedyly sort <code>nums</code> and pair from the smallest and the largest values.</p> <p>Proof:</p> <p>Let nums = [a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n-1</sub>, a<sub>n</sub>] and a<sub>0</sub> &lt;= a<sub>1</sub> &lt;= ... &lt;= a<sub>n-1</sub> &lt;= a<sub>n</sub>. Assume there exists another way (a<sub>i</sub>, a<sub>n-i+j</sub>) to form the pairs that has maximum pair sum smaller than forming by (a<sub>i</sub>, a<sub>n-i</sub>). In other words, max of (a<sub>i</sub> + a<sub>n-i+j</sub>) pairs should always be less than or equal to max of (a<sub>i</sub> + a<sub>n-i</sub>) pairs which implies that we can make the pair sum smaller by shuffling at least two pairs.</p> <p>Let's say the shuffled pairs originally have sum of <code>u</code> and <code>v</code> and the sums become <code>u + x</code> and <code>v - x</code> where x &gt;=0. Since max(<code>u + x</code>, <code>v - x</code>) must &gt;= max(<code>u</code>, <code>v</code>) violates previous assumption, the maximum value of pair sum forming by (ai, an-i) must be minimized.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1877-minimize-maximum-pair-sum-in-array/#code","title":"Code","text":"<pre><code>class Solution:\n    def minPairSum(self, nums: List[int]) -&gt; int:\n        nums.sort()\n        n = len(nums)\n        ans = 0\n        for i in range(int(n / 2)):\n            s = nums[i] + nums[n - 1 - i]\n            if s &gt; ans:\n                ans = s\n        return ans\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1887-reduction-operations-to-make-the-array-elements-equal/","title":"1887. Reduction Operations to Make the Array Elements Equal","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1887-reduction-operations-to-make-the-array-elements-equal/#description","title":"Description","text":"<p>We are asked to decrease all elements in <code>nums</code> to the lowest one. However, based on the rules described in the problem, we can only lower the element to the next smaller one and this counts as one operation.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1887-reduction-operations-to-make-the-array-elements-equal/#intuition","title":"Intuition","text":"<ol> <li>Count the numbers of values appeared in <code>nums</code> and sort <code>(value, number)</code> in descending oeder.</li> <li>For loop the sorted array from large to small and sum up the <code>value</code>.</li> <li>Notice that the larger values will be descreased in the next round.</li> </ol>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1887-reduction-operations-to-make-the-array-elements-equal/#code","title":"Code","text":"<pre><code>class Solution:\n    def reductionOperations(self, nums: List[int]) -&gt; int:\n        count = collections.Counter(nums)\n        s = sorted(count.items(), reverse=True)\n        ans = 0\n        c = 0\n        for i in range(len(s) - 1):\n            c += s[i][1]\n            ans += c\n        return ans\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/191-number-of-1-bits/","title":"191. Number of 1 Bits","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/191-number-of-1-bits/#description","title":"Description","text":"<p>Find the number of bit <code>1</code> in the binary representation of given integer.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/191-number-of-1-bits/#code","title":"Code","text":"<pre><code># Divide and remain\nclass Solution:\n    def hammingWeight(self, n: int) -&gt; int:\n        ans = 0\n        while n &gt; 0:\n            if n % 2 == 1:\n                ans += 1\n            n = n // 2\n        return ans\n\n# bit manipulation\nclass Solution:\n    def hammingWeight(self, n: int) -&gt; int:\n        ans = 0\n        while n:\n            n &amp;= n - 1\n            ans += 1\n        return ans\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1921-eliminate-maximum-number-of-monsters/","title":"1921. Eliminate Maximum Number of Monsters","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1921-eliminate-maximum-number-of-monsters/#description","title":"Description","text":"<p>In my opinion, the problem is sort of insufficient. For example, it doesn't say when can we eliminate a monster. Do we have to wait for them coming or can we kill one once the weapon is charged. Intuitively, I thought we are staying at 0 waiting for monsters coming but turning out that we can eliminate one once it's charged.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1921-eliminate-maximum-number-of-monsters/#code","title":"Code","text":"<pre><code>class Solution:\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -&gt; int:\n        time = [ dist[i] / speed[i] for i in range(len(dist))]\n        time.sort()\n\n        for i in range(len(time)):\n            if time[i] &lt;= i:\n                return i\n        return len(time)\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1930-unique-length-3-palindromic-subsequences/","title":"1930. Unique Length-3 Palindromic Subsequences","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1930-unique-length-3-palindromic-subsequences/#description","title":"Description","text":"<p>The name of question is already pretty clear so I don't repeat again.</p> <p>At the start of this question, I always start with the most intuitive approach. Therefore, I tried to for loop each character of <code>s</code> and make set intersection for the left substring and right substring. However, this will lead to time complexity of <code>O(n^2)</code> and the submission will be TLE.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1930-unique-length-3-palindromic-subsequences/#intuition","title":"Intuition","text":"<p>Refers to lee215's solution, this question can easily be linear time since the number of lowercase characters is limited.</p> <ol> <li>For loop <code>a</code> to <code>z</code> to find the first index of that character from left and right.</li> <li>Find the unique characters in between those indexes and sum to <code>ans</code></li> </ol> <p>This approach simply reverse the order of finding palindrome and the middle character which is clever. \ud83d\ude06</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1930-unique-length-3-palindromic-subsequences/#_1","title":"1930. Unique Length-3 Palindromic Subsequences","text":"<pre><code>class Solution:\n    def countPalindromicSubsequence(self, s: str) -&gt; int:\n        ## TLE O(n**2)\n        # ans = set()\n        # for i in range(1, len(s) - 1):\n        #     right = s[:i]\n        #     mid = s[i]\n        #     left = s[i+1:]\n        #     for inter in set(right).intersection(left):\n        #         if (inter, mid) not in ans:\n        #             ans.add((inter, mid))\n\n        # return len(ans)\n\n        ans = 0\n        for c in string.ascii_lowercase:\n            i, j = s.find(c), s.rfind(c)\n            if i &gt; -1:\n                ans += len(set(s[i + 1: j]))\n        return ans\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1980-find-unique-binary-string/","title":"1980. Find Unique Binary String","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1980-find-unique-binary-string/#description","title":"Description","text":"<p>The problem ask for one of the binary string of length <code>n</code> that doesn't exist in the given <code>nums</code>.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1980-find-unique-binary-string/#intuition","title":"Intuition","text":"<p>Since the length of <code>n</code> is given, one may list all possible combinations and remove by <code>nums</code>. However, the time complexity would be O(len(nums) * 2 ^ n).</p> <p>As we only requested to return one of the valid answers, we can think about what makes two binary different? The answer is ... at least one digit holds different value! Hence, we just need to create a binary string that have all <code>n</code> digits each being different with one of the number in <code>nums</code></p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/1980-find-unique-binary-string/#code","title":"Code","text":"<pre><code>class Solution:\n    def findDifferentBinaryString(self, nums: List[str]) -&gt; str:\n        ans = []\n        for i in range(len(nums)):\n            ans.append(\"1\" if nums[i][i] == \"0\" else \"0\")\n        return \"\".join(ans)\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2147-number-of-ways-to-divide-a-long-corridor/","title":"2147. Number of Ways to Divide a Long Corridor","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2147-number-of-ways-to-divide-a-long-corridor/#description","title":"Description","text":"<p>Given a string representing a corridor which contains only seat and plant. We are asked to find the number of combination of dividing them into segments. The segment must contains exactly two seats.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2147-number-of-ways-to-divide-a-long-corridor/#intuition","title":"Intuition","text":"<p>The only limitation is to have each segment containing exactly two seats so the key is to find how many plants between the segments. Hence:</p> <ol> <li>Find the indexes of seats in the corridor.</li> <li>Check for edge cases of (not enough seats).</li> <li>Count the number of plants between segment and return the production.</li> </ol>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2147-number-of-ways-to-divide-a-long-corridor/#code","title":"Code","text":"<pre><code>class Solution:\n    def numberOfWays(self, corridor: str) -&gt; int:\n        s = [i for i in range(len(corridor)) if corridor[i] == \"S\"]\n        if not s or len(s) % 2 != 0:\n            return 0\n        ans = [1]\n        # start from second segment, find the length with last segment\n        for i in range(2, len(s), 2):\n            ans.append(s[i] - s[i - 1])\n        return math.prod(ans) % (10 ** 9 + 7)\n</code></pre> <pre><code>S S P P S P S\n0 1 2 3 4 6 7\n  \u2191     \u2191\n i-1    i\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2265-count-nodes-equal-to-average-of-subtree/","title":"2265. Count Nodes Equal to Average of Subtree","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2265-count-nodes-equal-to-average-of-subtree/#description","title":"Description","text":"<p>Problem statement:</p> <p>Given the <code>root</code> of a binary tree, return the number of nodes where the value of the node is equal to the average of the values in its subtree.</p> <p>Note that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2265-count-nodes-equal-to-average-of-subtree/#intuition","title":"Intuition","text":"<p>Since the problem wants to find something with respect to the root node of all subtree, we use dfs to find the values we need.</p> <ol> <li>See from the root node, we need the sum and the number of node from both its left and right subtree in order to calculate the average of the root node.</li> <li>Therefore the return values of dfs function are the sum and the numbers of nodes (count).</li> <li>Dfs from root and store answer in a private variable.</li> </ol>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2265-count-nodes-equal-to-average-of-subtree/#code","title":"Code","text":"<pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def averageOfSubtree(self, root: Optional[TreeNode]) -&gt; int:\n        self.ans = 0\n        if root:\n            self.dfs(root)\n\n        return self.ans\n\n    def dfs(self, node):\n        s = node.val\n        count = 1\n        # get the sum and the count from left and right subtree\n        if node.left:\n            sub_s, sub_count = self.dfs(node.left)\n            s += sub_s\n            count += sub_count\n        if node.right:\n            sub_s, sub_count = self.dfs(node.right)\n            s += sub_s\n            count += sub_count\n        # check if the value of the node equals to the average\n        if node.val == int(s / count):\n            self.ans += 1\n        return s, count\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2391-minimum-amount-of-time-to-collect-garbage/","title":"2391. Minimum Amount of Time to Collect Garbage","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2391-minimum-amount-of-time-to-collect-garbage/#description","title":"Description","text":"<p>Since the trucks start from index 0 and must travel houses one by one, we only need to find the last index of every kind of garbage appearing. We can use prefix sum to decrease the summing time required, however, it doesn't affect time complexity much.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2391-minimum-amount-of-time-to-collect-garbage/#code","title":"Code","text":"<pre><code>class Solution:\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -&gt; int:\n        table = {\"M\": [0, 0], \"P\": [0, 0], \"G\": [0, 0]} # [count, last seen index] for M P G\n        for i in range(len(garbage)):\n            for g in garbage[i]:\n                table[g][0] += 1\n                table[g][1] = i\n        ans = 0\n        for c, i in table.values():\n            ans += c\n            ans += sum(travel[:i]) if i &gt; 0 else 0\n        return ans\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2642-design-graph-with-shortest-path-calculator/","title":"2642. Design Graph With Shortest Path Calculator","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2642-design-graph-with-shortest-path-calculator/#description","title":"Description","text":"<p>Classic shortest path question of applying Dijikstra's algorithm. Just be careful that the graph could be cyclic. A pretty good chance to review the graph related datqa strucure and algorithm. Here, we will use graph, priority queue, BFS, cache and dijikstra's.</p> <p>I recommand to watch neetcode's videos playlist for graph. Pretty helpful for beginner to learn and experienced to review, clear and clean.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2642-design-graph-with-shortest-path-calculator/#code","title":"Code","text":"<pre><code>class Graph:\n\n    def __init__(self, n: int, edges: List[List[int]]):\n        self.n = n\n        self.table = {i: set() for i in range(n)}\n        for edge in edges:\n            self.table[edge[0]].add((edge[2], edge[1]))\n\n    def addEdge(self, edge: List[int]) -&gt; None:\n        self.table[edge[0]].add((edge[2], edge[1]))\n\n    def shortestPath(self, node1: int, node2: int) -&gt; int:\n        heap = [(0, node1)]\n        # stored visited node to prevent falling to cycle\n        visited = set()\n        # dijikstra's algo\n        while heap:\n            cur_path, cur_node = heapq.heappop(heap)\n            if cur_node in visited:\n                continue\n            elif cur_node == node2:\n                return cur_path\n            visited.add(cur_node)\n\n            for nei_path, nei_node in self.table[cur_node]:\n                if nei_node not in visited:\n                    heapq.heappush(heap, (cur_path + nei_path, nei_node))\n\n        return -1\n\n# Your Graph object will be instantiated and called as such:\n# obj = Graph(n, edges)\n# obj.addEdge(edge)\n# param_2 = obj.shortestPath(node1,node2)\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2785-sort-vowels-in-a-string/","title":"2785. Sort Vowels in a String","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2785-sort-vowels-in-a-string/#description","title":"Description","text":"<p>The problem want to sort the characters of vowels in the string only in ASCII order. The vowels include the lowercases and the uppercases, i.e. <code>AEIOUaeiou</code>.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2785-sort-vowels-in-a-string/#intuition","title":"Intuition","text":"<ol> <li>Find all the vowels with positions and numbers.</li> <li>Loop the collected number table of vowels to place them by position.</li> </ol>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/2785-sort-vowels-in-a-string/#code","title":"Code","text":"<pre><code>class Solution:\n    def sortVowels(self, s: str) -&gt; str:\n        vowels = ['A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u']\n        # record the numbers of vowels and their positions\n        table = {v: 0 for v in vowels}\n        places = []\n        for i, c in enumerate(s):\n            if c in vowels:\n                table[c] += 1\n                places.append(i)\n\n        start = 0\n        s = list(s)\n        # replace by position\n        for v in vowels:\n            for i in places[start: start + table[v]]:\n                s[i] = v\n            start += table[v]\n        return \"\".join(s)\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/501-find-mode-in-binary-search-tree/","title":"501. Find Mode in Binary Search Tree","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/501-find-mode-in-binary-search-tree/#description","title":"Description","text":"<p>The problem wants to find the most common appeared value of a BST. Since it's an easy problem, I'wll just traverse all nodes and record the value in a map. Then find the most common values (including values of same count).</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/501-find-mode-in-binary-search-tree/#code","title":"Code","text":"<pre><code># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findMode(self, root: Optional[TreeNode]) -&gt; List[int]:\n        ans = []\n        ans_mode = 0\n        self.modes = {}\n        self.dfs(root)\n\n        for key, value in self.modes.items():\n            if value &gt; ans_mode:\n                ans = [key]\n                ans_mode = value\n            elif value == ans_mode:\n                ans.append(key)\n        return ans\n\n    def dfs(self, node):\n        if not node:\n            return\n        if node.val not in self.modes:\n            self.modes[node.val] = 1\n        else:\n            self.modes[node.val] = self.modes[node.val] + 1\n        self.dfs(node.left)\n        self.dfs(node.right)\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/935-knight-dialer/","title":"935. Knight Dialer","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/935-knight-dialer/#description","title":"Description","text":"<p>We are requested to find the number of combination for phone number of length <code>n</code>. The limitation is that the consecutive digits follow the movement of knight in chess.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/935-knight-dialer/#intuition","title":"Intuition","text":"<p>Since the possible paths from number <code>i</code> to <code>j</code> are fixed, we can construct the transition matrix for calculating the number of path ending what digit.</p> <p>In addition, since we will multiply the same matrix multiple times, we can actually benefit from the attibute of matrix (linear algebra stuff that I didn't think of it while solving this problem \ud83d\ude02). The time complexity becomes <code>O(logn)</code>.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/nov2023/935-knight-dialer/#code","title":"Code","text":"<pre><code>class Solution:\n    def knightDialer(self, n: int) -&gt; int:\n        def round(count):\n            return [\n                count[4] + count[6], # 4 and 6 can goes to 0 or say 0 came from 4 or 6\n                count[6] + count[8],\n                count[7] + count[9],\n                count[4] + count[8],\n                count[0] + count[3] + count[9],\n                0,\n                count[0] + count[1] + count[7],\n                count[2] + count[6],\n                count[1] + count[3],\n                count[2] + count[4]\n            ]\n\n        count = [1 for i in range(10)]\n        for i in range(n - 1):\n            count = round(count)\n        return sum(count) % (10 ** 9 + 7)\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/1220-count-vowels-permutation/","title":"1220. Count Vowels Permutation","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/1220-count-vowels-permutation/#description","title":"Description","text":"<p>The goal is to find the number of permutations of string following the rule described in the problem.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/1220-count-vowels-permutation/#intuition","title":"Intuition","text":"<p>Follow the rules of the problem, dynamically construt the number of string until matching requested length.</p> <ol> <li>Initialize <code>count</code> representing the number of substring ended with <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>.</li> <li>Loop calculate the combination with respect to the rules until length reaches <code>n</code>.</li> </ol>","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/1220-count-vowels-permutation/#code","title":"Code","text":"<pre><code>class Solution:\n    def countVowelPermutation(self, n: int) -&gt; int:\n        count = [1, 1, 1, 1, 1]\n        while n &gt; 1:\n            count = [\n                    count[1] + count[2] + count[4], # substring ended with *a* can be formed with substring ended with *e*, *i*, *u*\n                    count[0] + count[2], # same logic\n                    count[1] + count[3], \n                    count[2], \n                    count[2] + count[3]]\n            n -= 1\n        return sum(count) % (10 ** 9 + 7)\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/1356-sort-integers-by-the-number-of-1-bits/","title":"1356. Sort Integers by The Number of 1 Bits","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/1356-sort-integers-by-the-number-of-1-bits/#description","title":"Description","text":"<p>Sort the given array by the count of 1 of its binary representation, if the counts of numbers are the same, sort with the value ascending.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/1356-sort-integers-by-the-number-of-1-bits/#code","title":"Code","text":"<pre><code>class Solution:\n    def sortByBits(self, arr: List[int]) -&gt; List[int]:\n        return sorted(arr, key=lambda x : [bin(x).count('1'), x])s\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/2433-find-the-original-array-of-prefix-xor/","title":"2433. Find The Original Array of Prefix Xor","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/2433-find-the-original-array-of-prefix-xor/#description","title":"Description","text":"<p>Pretty straight forward problem, XOR cipher. To decrypt is to do xor again.</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/2433-find-the-original-array-of-prefix-xor/#code","title":"Code","text":"<pre><code>class Solution:\n    def findArray(self, pref: List[int]) -&gt; List[int]:\n        ans = [pref[0]]\n        for i in range(1, len(pref)):\n            ans.append(pref[i] ^ pref[i - 1])\n        return ans\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/458-poor-pigs/","title":"458. Poor Pigs","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/458-poor-pigs/#description","title":"Description","text":"<p>2023.10.29</p> <p>At first glance, this problem looks like to test the math/logic, but I couldn't figure it out in 10 minutes.</p> <p>Here's the solution I found helpful: 1. logirithm:      1. https://leetcode.com/problems/poor-pigs/solutions/4220289/c-log2-1-line/     2. https://leetcode.com/problems/poor-pigs/solutions/2387610/python-detailed-explanation-faster-than-98-easily-understood-simple-math/  2. stepby step concept:      1. https://leetcode.com/problems/poor-pigs/solutions/94266/another-explanation-and-solution/?envType=daily-question&amp;envId=2023-10-29</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/458-poor-pigs/#code","title":"Code","text":"<pre><code>## same as the second one\nclass Solution:\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -&gt; int:\n        pigs = 0\n        while (minutesToTest / minutesToDie + 1) ** pigs &lt; buckets:\n            pigs += 1\n        return pigs\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/5-longest-palindromic-substring/","title":"5. Longest Palindromic Substring","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/5-longest-palindromic-substring/#description","title":"Description","text":"<p>The problem statement is clear while the only thing we need to notice is that the substring here is contiguous (some other questions may not limit to).</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/5-longest-palindromic-substring/#intuition","title":"Intuition","text":"<ol> <li>Loop over every charactor as the middle of a palindrome.</li> <li>Find the length of the palindromic substring and compare it with current longest one.</li> </ol>","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/5-longest-palindromic-substring/#code","title":"Code","text":"<pre><code>class Solution:\n    def longestPalindrome(self, s: str) -&gt; str:\n        # initilize return ans and index of char\n        self.cur_max = s[0]\n        i = 0\n        while i &lt; len(s):\n            # two pointers point to the left and right char\n            l, r = i, i\n            self.findWithin(s, l, r)\n            # if the pivot are two same chars, e.g. cbbc, find again\n            if i + 1 &lt; len(s) and s[i] == s[i + 1]:\n                r += 1\n                self.findWithin(s, l, r)\n            i += 1        \n        return self.cur_max\n\n    def findWithin(self, s, l, r):\n        while l &gt;= 0 and r &lt; len(s) and s[l] == s[r]:\n            l -= 1\n            r += 1\n        # After leaving while loop, we actually need (l + 1) to (r - 1) substring\n        # so check (r - 1) - (l + 1) + 1 &gt; length of current max\n        if r - l - 1 &gt; len(self.cur_max):\n            self.cur_max = s[l + 1: r]\n</code></pre>","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/823-binary-trees-with-factors/","title":"823. Binary Trees with Factors","text":"","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/823-binary-trees-with-factors/#description","title":"Description","text":"<p>The problem wants us to find the number of possible binary trees that the value of each node equals to the product of its child nodes (both child nodes exist).</p>","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/823-binary-trees-with-factors/#intuition","title":"Intuition","text":"<p>Since every node (except leaf) can be one of the child nodes of another node, we can use dynamic programming to sum up the combination from small tree to big tree. For the example1 in the link, </p> <ol> <li>Sort the given array in ascending order.</li> <li>Initialize map to store available pair count for every unique node.</li> <li>Loop over possible combination from small to big tree.</li> </ol>","tags":["LeetCode"]},{"location":"career/leetcode/daily/oct2023/823-binary-trees-with-factors/#code","title":"Code","text":"<pre><code>class Solution:\n    def numFactoredBinaryTrees(self, arr: List[int]) -&gt; int:\n        # step 1\n        arr.sort()\n        # step 2\n        dp = {x: 1 for x in arr}\n        # step 3: loop over every combination, O(n^2)\n        for i in arr:\n            for j in arr:\n                # neglect impossible factor\n                if j &gt; i ** 0.5:\n                    break\n                # look for valid factor\n                if i % j == 0 and i // j in arr:\n                    if i // j == j:\n                        # e.g. 4 / 2 = 2, then dp[4] will have dp[2]^2 more composition since the left and right child can be dp[2]\n                        dp[i] += dp[j] * dp[j]\n                    else:\n                        # &lt;* 2&gt; because we can swap left and right\n                        dp[i] += dp[j] * dp[i // j] * 2\n        return sum(dp.values()) % (10 ** 9 + 7)\n</code></pre>","tags":["LeetCode"]},{"location":"career/system-design/","title":"System Design","text":"<p>I plan to post a series of articles about me reading the recently opensourced bytebytego system design pdf by its topics.</p>"},{"location":"career/system-design/bytebytego/01-database-isolation-levels/","title":"What are database isolation levels? What are they used for?","text":"<p>Before we discuss about isolation levels, let's review some important features used in modern database.</p>","tags":["System Design","ByteByteGo"]},{"location":"career/system-design/bytebytego/01-database-isolation-levels/#locks","title":"Locks","text":"<ul> <li>S Lock (Shared Lock): S Lock locks the write permission for other transactions while read operation is still allowed.</li> <li>X Lock (Exclusive Lock): X Lock, on the other hand, locks both read and write operation once a transaction obtained it.</li> </ul> Lock Read Write S Yes No X No No <ul> <li>range lock: lock multiple records in a table when SQL containing description like <code>WHERE length &gt; 10</code>.</li> </ul>","tags":["System Design","ByteByteGo"]},{"location":"career/system-design/bytebytego/01-database-isolation-levels/#read-phenomena","title":"Read Phenomena","text":"","tags":["System Design","ByteByteGo"]},{"location":"career/system-design/bytebytego/01-database-isolation-levels/#dirty-read","title":"Dirty Read","text":"<p>Dirty read occurs when a transaction reads some value while another transaction is updating the value without committing or even rollback at the end. Now, the first transaction reads may acquire non-committed value.</p>","tags":["System Design","ByteByteGo"]},{"location":"career/system-design/bytebytego/01-database-isolation-levels/#non-repeatable-read","title":"Non-repeatable Read","text":"<p>Similar to dirty read but the second transaction commits the change. Then, the first transaction would have inconsistent value during reads.</p>","tags":["System Design","ByteByteGo"]},{"location":"career/system-design/bytebytego/01-database-isolation-levels/#phamtom-read","title":"Phamtom Read","text":"<p>Phamtom read may occur when the query contains <code>WHERE</code> clause.</p> <p>While a transaction have selected records with <code>WHERE</code> and another transaction modifies some records within the <code>WHERE</code> statement. The selected records would change if the first transaction selects again.</p>","tags":["System Design","ByteByteGo"]},{"location":"career/system-design/bytebytego/01-database-isolation-levels/#isolation-levels","title":"Isolation Levels","text":"<p>There are four levels of isolation:</p> <ol> <li>Serializable: higest level, transaction must obtain x lock and range lock if used and can avoid phamtom read. See serializability for more. </li> <li>Repeatable read: transaction must get x lock (but not range lock) to read and write record. Phamtom read may occur but ensure non-repeatable read from happening. </li> <li>Read committed: transaction is allowed to read commited data during transaction so non-repeatable read may happend.</li> <li>Read uncommitted: basically no limit. Dirty read could happen.</li> </ol> Phamtom read Non-repeatable read Dirty read Serializable No No No Repeatable read Yes No No Read commited Yes Yes No Read uncommitted Yes Yes Yes","tags":["System Design","ByteByteGo"]},{"location":"career/system-design/bytebytego/01-database-isolation-levels/#other-important-knowledge","title":"Other Important Knowledge","text":"","tags":["System Design","ByteByteGo"]},{"location":"career/system-design/bytebytego/01-database-isolation-levels/#multiversion-concurrency-control","title":"Multiversion Concurrency Control","text":"<p>Multiversion concurrency control (MCC or MVCC) is widely used in RDBMS for concurrent transactional management. The idea is to have multiple snapshots for concurrent transactions to achieve isolation.</p>","tags":["System Design","ByteByteGo"]},{"location":"career/system-design/bytebytego/01-database-isolation-levels/#acid","title":"ACID","text":"<p>ACID stands for Atomicity, Consistency, Isolation and Durability.</p>","tags":["System Design","ByteByteGo"]},{"location":"career/system-design/bytebytego/bytebytego-system-design/","title":"What is ByteByteGo","text":"<p>ByteByteGo is an interview prep courses selling website held by Alex Xu and other talented software architecurers and engineers. They recently open-source one of their paid materials for anyone subscribed to them (free).</p>","tags":["System Design","ByteByteGo"]},{"location":"career/system-design/bytebytego/bytebytego-system-design/#why-i-want-to-do-this","title":"Why I want to do this","text":"<p>Since I've been interested in learning system design in a long period and have learned a lot from them, I want to organize my learning notes through the writing. Hope these will be helpful~</p>","tags":["System Design","ByteByteGo"]},{"location":"career/system-design/bytebytego/bytebytego-system-design/#the-plan","title":"The Plan","text":"<p>I will go through each topic in the pdf with some explanation and my extended ideas. \ud83d\ude0a</p>","tags":["System Design","ByteByteGo"]},{"location":"life/","title":"Life","text":"<p>I will share my life footprint.</p>"},{"location":"life/translate-python-doc-tw/","title":"Python\u5b98\u65b9\u6587\u4ef6\u7ffb\u8b6f \u7dda\u4e0bmeetup","text":"<p>This is an offline event happened in Taipei, so I write this in traditional chinese. \ud83d\ude01</p> <p>\u7ffb\u8b6f\u5b98\u65b9\u6587\u4ef6\u9019\u4ef6\u4e8b\u4f3c\u4e4e\u662f\u9760community\u53bb\u63a8\u52d5\u7684\uff0c\u5f9e\u5b83\u7684repo\u53ef\u4ee5\u770b\u51fa\u5df2\u7d93\u9032\u884c\u4e86\u4e00\u6bb5\u6642\u9593\u3002\u4f46\u6216\u8a31\u662f\u53c3\u8207\u7684\u3001\u77e5\u9053\u7684\u4eba\u592a\u5c11\uff0c\u6240\u4ee5\u624d\u8209\u8fa6\u50cf\u9019\u6a23\u5b50\u7684\u6d3b\u52d5\u5427XD\u3002 BTW\uff0c\u6709\u8208\u8da3\u53c3\u8207\u7ffb\u8b6f\u6d3b\u52d5\u7684\u4eba\u53ef\u4ee5\u53c3\u8003README\u7684\u8aaa\u660e\uff0c\u96a8\u6642\u53ef\u4ee5join\u3002</p> <p>\u95dc\u65bc\u5be6\u969b\u600e\u9ebc\u7ffb\u7684\u90e8\u5206\u5c31\u4e0d\u591a\u4ecb\u7d39\u4e86\uff0c\u4f86\u5206\u4eab\u4e00\u4e0b\u81ea\u5df1\u7684\u5fc3\u5f97\u3002\u7531\u65bc\u6700\u8fd1\u5de5\u4f5c\u4e0a\u6709\u7528\u5230 Python \u958b\u767c embedded web service\uff0c\u624d\u53c8\u958b\u59cb\u7528\u7528 Python \u505a\u958b\u767c\uff0c\u518d\u6b21\u7528\u5b83\u505a\u958b\u767c\u4e3b\u529b\u7684\u611f\u89ba\u9084\u771f\u662f\u4e0d\u932f\uff0c\u8a9e\u6cd5\u76f4\u89c0\u3001lib\u53c8\u8c50\u5bcc\uff0c\u4e0d\u662f\u53ea\u6709\u5237leetcode\u597d\u7528\u800c\u5df2 (lol)\u3002\u77e5\u9053\u9019\u500b\u6d3b\u52d5\u662f\u5728\u67d0\u5929\u6ed1ptt soft_job\u7684\u6642\u5019\uff0c\u6c92\u6709\u9019\u7a2econtribute to the community\u7d93\u9a57\u4f46\u53c8\u5f88\u60f3\u8a66\u8a66\u770b\u7684\u6211\uff0c\u7a81\u7136\u6709\u500b\u8072\u97f3\u544a\u8a34\u6211 \"this is the time\"\uff0c\u6240\u4ee5\u8d81\u9019\u8457\u611f\u89ba\u9084\u5b58\u5728\u7684\u6642\u5f8c\u99ac\u4e0a\u5831\u540dXD\u3002</p> <p>\u5c31\u7dda\u4e0b\u6d3b\u52d5\u672c\u8eab\u4f86\u8aaa\uff0c\u6211\u89ba\u5f97\u662f\u975e\u5e38\u68d2\u7684\uff0cstaff\u90fd\u5f88\u53cb\u5584\u53c8\u6709\u9edegeeky (\u662f\u597d\u8a71\u5427\ud83e\udd23)\uff0c\u5f9e\u8ac7\u5410\u4f86\u770b\u611f\u89ba\u90fd\u662fexperienced developers, no matter for job or community. \u53c3\u52a0\u8005\u5f9e\u5b78\u751f\u5230\u4e0a\u73ed\u65cf\u3001SDE \u5230 tech writer\u90fd\u6709\uff0c\u89ba\u5f97\u4ee4\u4eba\u9a5a\u8a1d\uff0c\u53ef\u4ee5\u628a\u9019\u9ebc\u591a\u4e0d\u540c\u80cc\u666f\u7684\u4eba\u805a\u96c6\u8d77\u4f86\uff0c\u8981\u7d66\u4e00\u500bRespect\u3002</p> <p>\u800c\u7ffb\u8b6f\u672c\u8eab\u7684\u8a71\uff0c\u7531\u65bc\u5e73\u5e38\u8b80doc\u6216spec\u90fd\u662f\u770b\u539f\u6587\uff0c\u5c0d\u65bc\u4e00\u4e9b\u7ffb\u8b6f\u7684glossary\u78ba\u5be6\u662f\u6709\u9ede\u82e6\u624b\uff0c\u4e0d\u904e\u597d\u5728repo\u88e1\u6709\u975e\u5e38\u591a\u5be6\u7528\u7684\u7ffb\u8b6freference\u53ef\u4ee5\u53c3\u8003\uff0c\u9019\u90e8\u5206\u975e\u5e38\u8cbc\u5fc3\u3002</p> <p>\u7d93\u904e\u9019\u6b21\u7684offline meetup\uff0c\u6211\u60f3\u4e4b\u5f8c\u61c9\u8a72\u6703\u7e7c\u7e8c\u627e\u6709\u8208\u8da3\u7684\u4e3b\u984c\u53c3\u52a0\uff0c\u4e26\u7e7c\u7e8c\u70baPython doc \u7ffb\u8b6f\u7e41\u9ad4\u4e2d\u6587\u7248\uff1b\u7562\u7adf\uff0c\u80fd\u770b\u5230\u81ea\u5df1\u7684commit\u51fa\u73fe\u5728\u9019\u9ebc\u6709\u540d\u7684public repo\u4e0a\uff0c\u61c9\u8a72\u662f\u4e00\u4ef6\u8d85\u9177\u7684\u4e8b\u5427\uff1f</p>","tags":["Python","Community"]},{"location":"life/gcsj2023/","title":"Google Cloud Study Jam 2023","text":"","tags":["Google Cloud Study Jam"]},{"location":"life/gcsj2023/#introduction","title":"Introduction","text":"<p>This is an event provided by Google to let developers learn cloud related skills from their Google Cloud Platform (GCP) for free. Also, the participants are rewarded with gifts based on their progress within the learning period. I've earned a small bag and a wireless charger last year XD and they provide even better gift this year, a mug!</p> <p>Register now:</p> <p>https://rsvp.withgoogle.com/events/csj-tw-s4</p>","tags":["Google Cloud Study Jam"]},{"location":"life/gcsj2023/#not-so-easy","title":"Not so Easy","text":"<p>From my experience last year, some labs (tasks to prove you actually learn) required enormous background knowledge on networking, virtualization and others to finish and I spent lots of time to either google or try-and-error it. Hence, I would like to share my soultion (not all labs but the one I think needed) here to help you finish this event.</p>","tags":["Google Cloud Study Jam"]},{"location":"tags/","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"tags/#bitbake","title":"BitBake","text":"<ul> <li>Configure Case Sensitivity of File System</li> <li>Extend Nginx Service from OpenEmbedded Default Recipe</li> <li>Install Python Modules in Yocto</li> </ul>"},{"location":"tags/#bytebytego","title":"ByteByteGo","text":"<ul> <li>What are database isolation levels? What are they used for?</li> <li>What is ByteByteGo</li> </ul>"},{"location":"tags/#code-server","title":"Code Server","text":"<ul> <li>Self-hosted Cloud Development Environment</li> </ul>"},{"location":"tags/#community","title":"Community","text":"<ul> <li>Python\u5b98\u65b9\u6587\u4ef6\u7ffb\u8b6f \u7dda\u4e0bmeetup</li> </ul>"},{"location":"tags/#cool","title":"Cool","text":"<ul> <li>Self-hosted Cloud Development Environment</li> </ul>"},{"location":"tags/#embedded","title":"Embedded","text":"<ul> <li>Embedded</li> <li>Configure Case Sensitivity of File System</li> <li>Extend Nginx Service from OpenEmbedded Default Recipe</li> <li>Install Python Modules in Yocto</li> </ul>"},{"location":"tags/#google-cloud-study-jam","title":"Google Cloud Study Jam","text":"<ul> <li>Google Cloud Study Jam 2023</li> </ul>"},{"location":"tags/#leetcode","title":"LeetCode","text":"<ul> <li>1160. Find Words That Can Be Formed by Characters</li> <li>1662. Check If Two String Arrays are Equivalent</li> <li>1424. Diagonal Traverse II</li> <li>1441. Build an Array With Stack Operations</li> <li>1503. Last Moment Before All Ants Fall Out of a Plank</li> <li>1535. Find the Winner of an Array Game</li> <li>1561. Maximum Number of Coins You Can Get</li> <li>1611. Minimum One Bit Operations to Make Integers Zero</li> <li>1630. Arithmetic Subarrays</li> <li>1685. Sum of Absolute Differences in a Sorted Array</li> <li>1727. Largest Submatrix With Rearrangements</li> <li>1743. Restore the Array From Adjacent Pairs</li> <li>1759. Count Number of Homogenous Substrings</li> <li>1814. Count Nice Pairs in an Array</li> <li>1838. Frequency of the Most Frequent Element</li> <li>1845. Seat Reservation Manager</li> <li>1846. Maximum Element After Decreasing and Rearranging</li> <li>1877. Minimize Maximum Pair Sum in Array</li> <li>1887. Reduction Operations to Make the Array Elements Equal</li> <li>191. Number of 1 Bits</li> <li>1921. Eliminate Maximum Number of Monsters</li> <li>1930. Unique Length-3 Palindromic Subsequences</li> <li>1980. Find Unique Binary String</li> <li>2147. Number of Ways to Divide a Long Corridor</li> <li>2265. Count Nodes Equal to Average of Subtree</li> <li>2391. Minimum Amount of Time to Collect Garbage</li> <li>2642. Design Graph With Shortest Path Calculator</li> <li>2785. Sort Vowels in a String</li> <li>501. Find Mode in Binary Search Tree</li> <li>935. Knight Dialer</li> <li>1220. Count Vowels Permutation</li> <li>1356. Sort Integers by The Number of 1 Bits</li> <li>2433. Find The Original Array of Prefix Xor</li> <li>458. Poor Pigs</li> <li>5. Longest Palindromic Substring</li> <li>823. Binary Trees with Factors</li> </ul>"},{"location":"tags/#nginx","title":"Nginx","text":"<ul> <li>Extend Nginx Service from OpenEmbedded Default Recipe</li> </ul>"},{"location":"tags/#ngrok","title":"Ngrok","text":"<ul> <li>Self-hosted Cloud Development Environment</li> </ul>"},{"location":"tags/#oop","title":"OOP","text":"<ul> <li>Object-Oriented Programming Introduction</li> </ul>"},{"location":"tags/#python","title":"Python","text":"<ul> <li>Install Python Modules in Yocto</li> <li>Python\u5b98\u65b9\u6587\u4ef6\u7ffb\u8b6f \u7dda\u4e0bmeetup</li> </ul>"},{"location":"tags/#system-design","title":"System Design","text":"<ul> <li>What are database isolation levels? What are they used for?</li> <li>What is ByteByteGo</li> </ul>"},{"location":"tags/#yocto","title":"Yocto","text":"<ul> <li>Configure Case Sensitivity of File System</li> <li>Extend Nginx Service from OpenEmbedded Default Recipe</li> <li>Install Python Modules in Yocto</li> </ul>"}]}